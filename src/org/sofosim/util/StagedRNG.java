package org.sofosim.util;

import java.util.LinkedHashMap;
import java.util.Map.Entry;

import org.nzdis.micro.random.MersenneTwister;

/**
 * StagedRNG is a simple tool to specify bins with individual probabilities in order to draw random 
 * values from a specified value range (group/bin) weighted by the specified bin probability. The 
 * draw is staged by first performing a probabilistic draw that resolves a specific bin, before 
 * performing a random (normal) draw within that bin.
 * To initialise, specify the bins and the probabilities using {@link #addGroupDistributionMapEntry(String, Float)} 
 * and the corresponding value range to draw from using {@link #addGroupBoundaryValueMapEntry(String, Integer)}.
 * The identifiers and order of entry in both methods must be identical. Once entered, run {@link #prepareDistributions()} 
 * and draw values using {@link #nextInt(MersenneTwister)}. Suggested implementation is by extension.
 * 
 * @author Christopher Frantz (cf@christopherfrantz.org)
 *
 */
public class StagedRNG {
	
	
	/**
	 * Indicates whether {@link #prepareDistributions()} has successfully run prior to retrieving
	 * random values.
	 */
	private boolean initialised = false;
	
	/**
	 * Indicates whether StagedRNG has been properly initialised.
	 * @return
	 */
	protected boolean isInitialised() {
		return initialised;
	}
	
	/**
	 * Group distribution map managing bins and associated percentages. Ensure that percentages
	 * add up to 1. Run {@link #prepareDistributions()} to see whether this is the case.
	 * Order of entry is order of processing.
	 */
	private LinkedHashMap<String, Float> groupDistributionMap = new LinkedHashMap<>();
	
	/**
	 * Adds entry to group distribution map, which keeps group identifiers and associated percentages 
	 * for random draw. Order of entry is order of bins in final distribution.
	 * Fill corresponding value range to draw from using {@link #addGroupBoundaryValueMapEntry(String, Integer)}.
	 * Once all entries are added, call {@link #prepareDistributions()}, before using {@link #nextInt(MersenneTwister)}
	 * to draw random value.
	 * @param groupKey Group identifier
	 * @param percentage Probability for drawing entry from that group value range (as specified using {@link #addGroupBoundaryValueMapEntry(String, Integer)}.
	 */
	protected void addGroupDistributionMapEntry(String groupKey, Float percentage) {
		if (groupDistributionMap.containsKey(groupKey)) {
			System.err.println("Warning: The key " + groupKey + " has already been added previously. Value will be overwritten.");
		}
		groupDistributionMap.put(groupKey, percentage);
		// Reset to enforce reinitialisation
		initialised = false;
	}
	
	/**
	 * Upper group boundaries (i.e., range of entry is value of previous entry (or zero) and current entry value).
	 * Example: First entry is 500, second entry is 1000. The first group range is thus from 0 to 500; the second
	 * from 501 to 1000;
	 * Added values should be actual domain-related values as used in the simulation.
	 * This map has to have the same number of entries and the same order as {@link #groupDistributionMap} and is 
	 * to be filled prior to running {@link #prepareDistributions()}.
	 */
	private LinkedHashMap<String, Integer> groupBoundaryValueMap = new LinkedHashMap<>();
	
	/**
	 * Adds upper boundary value for given group, from which the actual random value is drawn with the probability
	 * specified in {@link #addGroupDistributionMapEntry(String, Float)}. Ensure that a corresponding entry in the 
	 * same order of entry and the same group identifiers has been added.
	 * Once all entries are added, call {@link #prepareDistributions()}, before using {@link #nextInt(MersenneTwister)}
	 * to draw random value.
	 * @param group Group identifier (identical to the one used in {@link #addGroupDistributionMapEntry(String, Float)}.
	 * @param upperBoundary Upper boundary value for the given group. Lower boundary is previous entry value 
	 * (or 0 if no previous entry exists).
	 */
	protected void addGroupBoundaryValueMapEntry(String group, Integer upperBoundary) {
		if (groupBoundaryValueMap.containsKey(group)) {
			System.err.println("Warning: The key " + group + " has already been added previously. Value will be overwritten.");
		}
		groupBoundaryValueMap.put(group, upperBoundary);
		// Reset to enforce reinitialisation
		initialised = false;
	}
	
	/**
	 * Aggregated group percentiles (i.e., sum of percentages of preceding and respective current 
	 * entry taken from {@link #groupDistributionMap}. Generated by {@link #prepareDistributions()}. 
	 * Added in same order as provided in {@link #groupDistributionMap}.
	 */
	private LinkedHashMap<String, Float> aggregatedGroupDistributionMap = new LinkedHashMap<>();
	
	/**
	 * Returns int value contained within initialised distribution (with varying probabilities for bins). 
	 * For weighted draw across discrete values, use {@link #nextDiscreteInt(MersenneTwister)}.
	 * Returns -1 if random value could not be drawn.
	 * @return
	 */
	public int nextInt(MersenneTwister rngInstance) {
		if (!initialised) {
			throw new RuntimeException("StagedRNG has not been initialised properly. Please add groups/bins and corresponding probabilities and value ranges first.");
		}
		// Take random float value between 0 and 1
		Float val = rngInstance.nextFloat(true, true);
		// Keep track of origin of bin
		int previousValue = 0;
		for (Entry<String, Float> entry: aggregatedGroupDistributionMap.entrySet()) {
			// Retrieve first entry that falls within bin probability
			if (val < entry.getValue()) {
				// Return next integer (origin + random(boundary - origin))
				return previousValue + rngInstance.nextInt((groupBoundaryValueMap.get(entry.getKey()) - previousValue));
			}
			// Store previous round's boundary value to determine origin to calculate range (boundary-origin)
			previousValue = groupBoundaryValueMap.get(entry.getKey());
		}
		// Worst case --> -1
		return -1;
	}
	
	/**
	 * Returns int value specified as boundary value based on initialised distribution. 
	 * This variant of {@link #nextInt(MersenneTwister)} does not draw values within bins, but
	 * simply returns the boundary values.
	 * Returns -1 if random value could not be drawn.
	 * @return
	 */
	public int nextDiscreteInt(MersenneTwister rngInstance) {
		if (!initialised) {
			throw new RuntimeException("StagedRNG has not been initialised properly. Please add groups/bins and corresponding probabilities and value ranges first.");
		}
		// Take random float value between 0 and 1
		Float val = rngInstance.nextFloat(true, true);
		
		for (Entry<String, Float> entry: aggregatedGroupDistributionMap.entrySet()) {
			// Retrieve first entry that falls within bin probability
			if (val < entry.getValue()) {
				// Return next boundary value
				return groupBoundaryValueMap.get(entry.getKey());
			}
		}
		// Worst case --> -1
		return -1;
	}
	
	/**
	 * Prepares distributions for weighted random draws.
	 * Throws error if distribution values don't add up to 1.
	 */
	protected void prepareDistributions() {
		
		// Reset in case of repeated calls
		initialised = false;
		
		// Reset aggregated percentiles
		aggregatedGroupDistributionMap.clear();
		
		// Sanity checks
		if (groupDistributionMap.isEmpty() || groupBoundaryValueMap.isEmpty()) {
			throw new RuntimeException("No bin/group probabilities and/or values have been entered. Ensure that both are entered"
					+ "before calling prepareDistributions().");
		}
		
		if (!groupDistributionMap.keySet().equals(groupBoundaryValueMap.keySet())) {
			throw new RuntimeException("Group/bin identifiers in group distribution map and group boundary value map differ. "
					+ "Ensure that both are entered completely before calling prepareDistributions().");
		}
		
		// Calculate sum of percentages for potential scaling
		Float sum = 0f;
		for (Entry<String,Float> entry: groupDistributionMap.entrySet()) {
			sum += entry.getValue();
		}
		
		if (sum > 1.01f) {
			throw new RuntimeException("Sum of percentage is greater than 1.");
		}
		if (sum < 0.99f) {
			// Scale to 1
			for (Entry<String,Float> entry: groupDistributionMap.entrySet()) {
				groupDistributionMap.put(entry.getKey(), entry.getValue() * (1f/sum));
			}
		}
		
		// Redo calculation of sum of percentages after scaling
		sum = 0f;
		for (Entry<String,Float> entry: groupDistributionMap.entrySet()) {
			sum += entry.getValue();
		}
		
		if (sum > 1.01f || sum < 0.99f) {
			throw new RuntimeException("Automated scaling didn't work. Sum of percentage is greater or smaller than 1 (Value: " + sum + "). Map: " + groupDistributionMap);
		}
		
		sum = 0f;
		System.out.println("Final (potentially scaled) values for staged RNG distribution");
		for (Entry<String,Float> entry: groupDistributionMap.entrySet()) {
			sum += entry.getValue();
			System.out.println("Entry: " + entry.getKey() + ", Value: " + entry.getValue());
			// Fill aggregated map
			aggregatedGroupDistributionMap.put(entry.getKey(), sum);
		}
		// Now ready for drawing values
		initialised = true;
		System.out.println("Sum of distribution percentages: " + sum);
	}
	
	
}
